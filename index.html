<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>珈琲用ストップウォッチ＋投入通知</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#151823;
      --panel2:#10131b;
      --text:#e9eef7;
      --muted:#9aa6b2;
      --line:#2a3142;

      --accent:#4ea1ff;
      --accent-rgb:78,161,255;
      --warn:#ff9a3c;   /* オレンジ */
      --danger:#ff4d4d; /* 赤 */
      --ok:#6b7280;     /* グレー */

      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
      background: radial-gradient(900px 500px at 20% 0%, rgba(var(--accent-rgb),.12), transparent 60%),
                  radial-gradient(900px 500px at 80% 20%, rgba(255,154,60,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
      padding:16px 16px 22px;
    }

    .app{
      max-width: 760px;
      margin: 0 auto;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 60%), var(--panel);
      border:1px solid rgba(255,255,255,.06);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding:14px;
    }

    .top{
      display:flex;
      gap:12px;
      align-items:stretch;
      flex-wrap:wrap;
    }

    .timeBox{
      flex: 1 1 260px;
      padding:14px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:8px;
      background: linear-gradient(180deg, rgba(var(--accent-rgb),.10), transparent 65%), var(--panel2);
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.06);
    }
    .timeLabel{
      color:var(--muted);
      font-size:12px;
      letter-spacing:.05em;
    }
    .timeValue{
      font-size:56px;
      font-weight:800;
      letter-spacing:.03em;
      line-height:1;
      font-variant-numeric: tabular-nums;
    }

    .timeLine{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:10px;
    }
    .sideAmounts{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:flex-start;
      font-variant-numeric: tabular-nums;
    }

    .sideAmounts{
      width: 100%;
    }
    .line{
      width: 100%;
      justify-content: flex-start;
    }
    .line .v, .line .t{
      display:inline-block;
    }
    .line .v{
      min-width: 6ch; /* 例: "140ml" など */
    }
    .line .t{
      min-width: 7ch; /* 例: "+00:05" */
      text-align: right;
    }
    .is-empty{
      visibility: hidden; /* 幅は維持して非表示にする */
    }
    .line{
      display:flex;
      align-items:baseline;
      gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-size: 13px;
      white-space:nowrap;
      min-width: 120px;
    }
    .line .k{
      color: var(--muted);
      font-weight:800;
      letter-spacing:.02em;
      min-width: 52px; /* 「直近：」「次　：」を揃える */
      text-align:left;
    }
    .line .v{
      font-weight:800;
    }

    .line .t{
      color: var(--muted);
      font-weight:700;
      margin-left: 6px;
      font-variant-numeric: tabular-nums;
    }

    .controls{
      flex: 2 1 360px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 160px;
      flex: 1 1 160px;
    }
    .field label{
      color:var(--muted);
      font-size:12px;
    }

    select, input[type="number"], input[type="text"], button{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }

    select:focus, input:focus{
      border-color: rgba(var(--accent-rgb),.55);
      box-shadow: 0 0 0 3px rgba(var(--accent-rgb),.18);
    }

    button{
      cursor:pointer;
      user-select:none;
      font-weight:700;
      letter-spacing:.01em;
    }

    button.primary{
      background: linear-gradient(180deg, rgba(var(--accent-rgb),.95), rgba(var(--accent-rgb),.75));
      border-color: rgba(var(--accent-rgb),.65);
      color:#07101c;
    }

    button.ghost{
      background: rgba(255,255,255,.04);
    }

    button.danger{
      background: rgba(255,77,77,.10);
      border-color: rgba(255,77,77,.35);
    }

    button:disabled, select:disabled, input:disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .btns > *{ flex: 1 1 120px; }
    .btns > .btnRow{ flex: 1 1 100%; }

    /* 操作：リセット（左）＋スタート（右）を同一行に固定 */
    .btnRow{
      display:flex;
      gap:10px;
      width:100%;
    }
    .btnRow > button{
      flex:1 1 0;
      min-width:0;
    }

    .help{
      color: var(--muted);
      font-size:12px;
      line-height:1.5;
    }

    .error{
      display:none;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,77,77,.35);
      background: rgba(255,77,77,.10);
      color: #ffd0d0;
      font-size: 13px;
    }
    .error.show{ display:block; }
    .req{
      color: var(--danger);
      font-weight: 900;
      margin-left: 4px;
    }

    .inputInvalid{
      border-color: rgba(255,77,77,.60) !important;
      box-shadow: 0 0 0 3px rgba(255,77,77,.18) !important;
    }

    .fileInput{
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }


    /* Steps */
    .stepsHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .stepsHeader h2{
      margin:0;
      font-size:15px;
      letter-spacing:.02em;
    }
    .stepsHeader .sub{
      color:var(--muted);
      font-size:12px;
    }

    .table{
      width:100%;
      border-collapse:separate;
      border-spacing: 0 10px;
    }

    .tr{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      border-radius: 14px;
      overflow:hidden;
    }

    .tr td{
      padding:10px;
      vertical-align:middle;
      border-top:1px solid rgba(255,255,255,.0);
    }

    .cellTime, .cellAmount, .cellAction{
      width: 33%;
    }

    .timePick{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .timePick select{
      min-width: 96px;
      flex: 1 1 96px;
    }

    .amountWrap{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .amountWrap input{
      width: 100%;
    }
    .unitBadge{
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      color: var(--muted);
      background: rgba(255,255,255,.03);
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }

    .rowMeta{
      color:var(--muted);
      font-size:12px;
      margin-top:6px;
      font-variant-numeric: tabular-nums;
    }

    /* states */
    .tr.invalid{
      border-color: rgba(255,77,77,.45);
      background: rgba(255,77,77,.08);
    }
    .tr.next-up{
      border-color: rgba(var(--accent-rgb),.55);
      background: rgba(var(--accent-rgb),.10);
    }
    .tr.next-orange{
      border-color: rgba(255,154,60,.70);
      background: rgba(255,154,60,.14);
    }
    .tr.next-red{
      border-color: rgba(255,77,77,.70);
      background: rgba(255,77,77,.14);
    }
    .tr.completed{
      opacity:.62;
      filter: grayscale(.35);
    }
    .tr.completed td{
      color: rgba(233,238,247,.75);
    }

    .flash{
      animation: flash .35s ease-out 1;
    }
    @keyframes flash{
      0%{ box-shadow: 0 0 0 0 rgba(255,154,60,.0); }
      30%{ box-shadow: 0 0 0 8px rgba(255,154,60,.20); }
      100%{ box-shadow: 0 0 0 0 rgba(255,154,60,.0); }
    }

    .footerNote{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,.14);
      background: rgba(255,255,255,.02);
    }

    /* ---- Time modal (追加要件2) ---- */
    .modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 9999;
    }
    .modal.hidden{ display:none; }
    .modalBackdrop{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(2px);
    }
    .modalPanel{
      position:relative;
      width: min(520px, calc(100vw - 24px));
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent 65%), var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      margin-bottom: 12px;
    }
    .modalTitle{
      font-weight: 900;
      letter-spacing: .02em;
      font-size: 16px;
    }
    .modalBody{ display:flex; flex-direction:column; gap:10px; }
    .modalFooter{
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .timeBtn{
      width: 100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-variant-numeric: tabular-nums;
    }
    .timeBtn .sub{ color: var(--muted); font-weight:700; }
    /* ---- Theme settings (v7) ---- */
    .topbar{
      display:flex;
      justify-content:flex-end;
      align-items:center;
      padding: 4px 2px 0;
    }
    .gearBtn{
      width: 44px;
      height: 44px;
      border-radius: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(var(--accent-rgb),.14), rgba(255,255,255,.02));
      border:1px solid rgba(var(--accent-rgb),.20);
      box-shadow: 0 10px 20px rgba(0,0,0,.20);
      padding:0;
    }
    .gearBtn svg{
      width:22px;
      height:22px;
      fill: rgba(233,238,247,.92);
      opacity:.95;
    }
    .themeSwatches{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .swatch{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 8px 16px rgba(0,0,0,.18);
      cursor:pointer;
    }
    .swatch:focus{
      outline:none;
      border-color: rgba(var(--accent-rgb),.55);
      box-shadow: 0 0 0 3px rgba(var(--accent-rgb),.18);
    }
    

    @media (max-width: 520px){
      .timeValue{ font-size:48px; }
      .cellTime, .cellAmount, .cellAction{ width:auto; display:block; }
      .tr td{ display:block; padding:10px 10px 0; }
      .tr td:last-child{ padding-bottom:10px; }
      .cellAction{ padding-top:8px; }
      /* モバイルでも「リセット＋スタート」は2分割のまま */
      .btnRow{ width:100%; }
    }
  
/* === v6_6: Start/Reset double height === */
.controls-row {
  display: flex;
  gap: 12px;
}

.controls-row .btn {
  flex: 1;
  min-height: 100px; /* roughly 2-line height */
  font-size: 1.1rem;
}



/* === v6_8: Start/Reset taller via padding (2-line feel) === */
.btnRow > button{
  padding-top: 22px;
  padding-bottom: 22px;
  font-size: 16px;
  line-height: 1.15;
}


/* === v6_9: Top area color accents (same theme, clearer) === */
.card.top{
  position: relative;
  overflow: hidden;
  border-color: rgba(var(--accent-rgb),.18);
}
.card.top::before{
  content:"";
  position:absolute;
  inset:-1px;
  pointer-events:none;
  border-radius: var(--radius);
  background:
    radial-gradient(700px 260px at 18% 0%,
      rgba(var(--accent-rgb),.18),
      transparent 60%);
  opacity: .95;
}
.card.top > *{ position: relative; }

.timeLabel{
  color: rgba(var(--accent-rgb),.85);
  letter-spacing: .04em;
}

.timeValue{
  text-shadow: 0 0 18px rgba(var(--accent-rgb),.16);
}

.sideAmounts .line{
  background: linear-gradient(180deg, rgba(var(--accent-rgb),.09), rgba(255,255,255,.02));
  border-color: rgba(var(--accent-rgb),.14);
}
.sideAmounts .line .k{
  color: rgba(233,238,247,.92);
}

</style>
</head>

<body>
  <div class="app">

    <div class="topbar">
      <button id="themeBtn" class="gearBtn ghost" type="button" aria-label="テーマ色">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M19.14,12.94c0.04-0.31,0.06-0.63,0.06-0.94s-0.02-0.63-0.06-0.94l2.03-1.58
          c0.18-0.14,0.23-0.41,0.12-0.61l-1.92-3.32c-0.11-0.2-0.36-0.28-0.57-0.2l-2.39,0.96
          c-0.5-0.38-1.04-0.69-1.63-0.92L14.4,2.5C14.36,2.22,14.12,2,13.84,2h-3.68
          C9.88,2,9.64,2.22,9.6,2.5L9.24,5.39C8.65,5.62,8.11,5.93,7.61,6.31L5.22,5.35
          c-0.21-0.08-0.46,0-0.57,0.2L2.73,8.87C2.62,9.07,2.67,9.34,2.85,9.48l2.03,1.58
          C4.84,11.37,4.82,11.69,4.82,12s0.02,0.63,0.06,0.94L2.85,14.52c-0.18,0.14-0.23,0.41-0.12,0.61
          l1.92,3.32c0.11,0.2,0.36,0.28,0.57,0.2l2.39-0.96c0.5,0.38,1.04,0.69,1.63,0.92L9.6,21.5
          c0.04,0.28,0.28,0.5,0.56,0.5h3.68c0.28,0,0.52-0.22,0.56-0.5l0.36-2.89
          c0.59-0.23,1.13-0.54,1.63-0.92l2.39,0.96c0.21,0.08,0.46,0,0.57-0.2l1.92-3.32
          c0.11-0.2,0.06-0.47-0.12-0.61L19.14,12.94z M12,15.5c-1.93,0-3.5-1.57-3.5-3.5
          S10.07,8.5,12,8.5s3.5,1.57,3.5,3.5S13.93,15.5,12,15.5z"/>
        </svg>
      </button>
    </div>

    <div class="card top">
      <div class="timeBox" id="timeBox">
        <div class="timeLabel">経過時間</div>
        <div class="timeLine">
          <div class="timeValue" id="elapsed">00:00</div>
          <div class="sideAmounts" id="sideAmounts" aria-live="polite">
            <div class="line" id="lastLine"><span class="k">直近：</span><span class="v" id="lastAmountText" class="is-empty"></span><span class="t" id="lastDeltaText" class="is-empty"></span></div>
            <div class="line" id="nextLine"><span class="k">次　：</span><span class="v" id="nextAmountText" class="is-empty"></span><span class="t" id="nextDeltaText" class="is-empty"></span></div>
          </div>
        </div>
        <div class="help">表示は mm:ss（内部はミリ秒管理）</div>
        <!-- countdown ("次まで") はUI重複のため非表示（必要になれば後で復活可能） -->
      </div>

      <div class="controls">
        <div class="row">
          <div class="field">
            <label id="unitLabel">量(ml)</label>
            <select id="unitSelect">
              <option value="ml" selected>ml</option>
              <option value="l">l</option>
              <option value="mg">mg</option>
              <option value="g">g</option>
            </select>
          </div>

          <div class="field" style="min-width:220px;flex:2 1 220px;">
            <label>操作</label>
            <div class="btns">
              <div class="btnRow">
                <button id="resetBtn" class="ghost" disabled>リセット</button>
                <button id="startStopBtn" class="primary">スタート</button>
              </div>
              <button id="addStepBtn" class="ghost" style="flex:1 1 100%;">＋ ステップ追加</button>
            </div>
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:220px;flex:2 1 220px;">
            <label>タイトル<span class="req">*</span></label>
            <input id="titleInput" type="text" placeholder="例：浅煎り 朝用レシピ" />
          </div>

          <div class="field" style="min-width:220px;flex:2 1 220px;">
            <label>プリセット（CSV）</label>
            <div class="btns">
              <button id="exportBtn" class="ghost">保存<br>（エクスポート）</button>
              <button id="importBtn" class="ghost">読み込み<br>（インポート）</button>
            </div>
            <input id="importFile" class="fileInput" type="file" accept=".csv,text/csv" />
          </div>
        </div>

        <div id="errorBox" class="error"></div>
        <div class="help">
          ・走行中は「時間/量/単位/追加/削除/リセット」は無効。<br/>
          ・同一時刻は同時に通知。<br/>
          ・通知は音（ピーン）＋バイブ（対応端末）＋画面強調。
        </div>
      </div>
    </div>

    <div class="card">
      <div class="stepsHeader">
        <div>
          <h2>ステップ</h2>
          <div class="sub">「時間」＝タップして分秒を設定（00:00〜59:59、1秒刻み）／「量」＝整数（0以上）</div>
        </div>
      </div>

      <table class="table" aria-label="ステップ一覧">
        <tbody id="stepsTbody"></tbody>
      </table>

      <div class="footerNote">
        Next行の色：到達後 0〜3秒＝オレンジ／3秒以降＝赤。<br/>
        ※「完了（グレーアウト）」は “次ステップの時間に到達したら” として扱う（最後のステップは到達後6秒で完了）。
      </div>
    </div>
  </div>

  <!-- 時間設定モーダル（追加要件2：分秒を一気に確定してからソート） -->
  <div id="timeModal" class="modal hidden" aria-hidden="true">
    <div class="modalBackdrop" id="timeModalBackdrop" aria-label="閉じる"></div>
    <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="timeModalTitle">
      <div class="modalHeader">
        <div class="modalTitle" id="timeModalTitle">時間設定</div>
        <button id="timeModalClose" class="ghost" type="button" aria-label="閉じる">×</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <div class="field">
            <label>分</label>
            <select id="modalMm"></select>
          </div>
          <div class="field">
            <label>秒</label>
            <select id="modalSs"></select>
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:220px;flex:2 1 220px;">
            <label>量（任意）</label>
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
              <label style="display:flex;align-items:center;gap:8px;color:var(--muted);font-size:13px;">
                <input id="modalAmountEnable" type="checkbox" />
                量も設定する
              </label>
              <input id="modalAmountInput" type="number" inputmode="numeric" min="0" step="1" placeholder="整数 (0以上)" style="flex:1 1 160px;min-width:160px;" />
              <span class="unitBadge" id="modalAmountUnit">ml</span>
            </div>
          </div>
        </div>

        <div class="rowMeta" id="modalTargetInfo"></div>
      </div>
      <div class="modalFooter">
        <button id="modalUnsetBtn" class="ghost" type="button">未設定にする</button>
        <button id="modalCancelBtn" class="ghost" type="button">キャンセル</button>
        <button id="modalOkBtn" class="primary" type="button">決定</button>
      </div>
    </div>
  </div>

  <!-- テーマ色モーダル（v7） -->
  <div id="themeModal" class="modal hidden" aria-hidden="true">
    <div class="modalBackdrop" id="themeModalBackdrop" aria-label="閉じる"></div>
    <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="themeModalTitle">
      <div class="modalHeader">
        <div class="modalTitle" id="themeModalTitle">テーマ色</div>
        <button id="themeModalClose" class="ghost" type="button" aria-label="閉じる">×</button>
      </div>
      <div class="modalBody">
        <div class="row">
          <div class="field" style="min-width:220px;flex:1 1 220px;">
            <label>基調色</label>
            <input id="themeColorInput" type="color" value="#4ea1ff" />
          </div>
          <div class="field" style="min-width:220px;flex:2 1 220px;">
            <label>プリセット</label>
            <div class="themeSwatches">
              <button type="button" class="swatch" data-color="#4ea1ff" style="background:#4ea1ff;"></button>
              <button type="button" class="swatch" data-color="#22c55e" style="background:#22c55e;"></button>
              <button type="button" class="swatch" data-color="#a855f7" style="background:#a855f7;"></button>
              <button type="button" class="swatch" data-color="#f97316" style="background:#f97316;"></button>
              <button type="button" class="swatch" data-color="#ef4444" style="background:#ef4444;"></button>
              <button type="button" class="swatch" data-color="#14b8a6" style="background:#14b8a6;"></button>
            </div>
          </div>
        </div>
        <div class="rowMeta">※「OK」で反映します（保存は未実装）。</div>
      </div>
      <div class="modalFooter">
        <button id="themeCancelBtn" class="ghost" type="button">キャンセル</button>
        <button id="themeOkBtn" class="primary" type="button">OK</button>
      </div>
    </div>
  </div>


  <script>
    (() => {
      'use strict';

      /** =========================================================
       * 方針（UI変更を容易にするための構造）
       * - State（データ）と ViewModel（表示用加工）と Render（DOM更新）を分離
       * - Tick は「状態更新→ViewModel生成→Render」に統一
       * - DOM参照は一括キャッシュし、Renderはキャッシュのみを操作
       * ========================================================= */

      /** ------------------------------
       * Constants / Utilities
       * ------------------------------ */
      const TICK_MS = 150;

      const pad2 = (n) => String(n).padStart(2, '0');

      function msToMmSs(ms){
        const totalSec = Math.max(0, Math.floor(ms / 1000));
        const mm = Math.floor(totalSec / 60) % 60;
        const ss = totalSec % 60;
        return `${pad2(mm)}:${pad2(ss)}`;
      }

      function mmssToMs(mm, ss){
        if (mm == null || ss == null) return null;
        const m = Number(mm), s = Number(ss);
        if (!Number.isInteger(m) || !Number.isInteger(s)) return null;
        if (m < 0 || m > 59 || s < 0 || s > 59) return null;
        return (m * 60 + s) * 1000;
      }

      function buildOptions(from, to){
        const frag = document.createDocumentFragment();
        for(let i=from;i<=to;i++){
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = pad2(i);
          frag.appendChild(opt);
        }
        return frag;
      }

      function newId(){
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      function escapeCsvTitle(title){
        return String(title).replace(/\r?\n/g, ' ').replace(/"/g, '""');
      }

      /** ------------------------------
       * DOM Cache
       * ------------------------------ */
      const $ = (id) => document.getElementById(id);

      const dom = {
        // top
        timeBox: $('timeBox'),
        elapsed: $('elapsed'),
        unitSelect: $('unitSelect'),
        unitLabel: $('unitLabel'),
        startStopBtn: $('startStopBtn'),
        resetBtn: $('resetBtn'),
        addStepBtn: $('addStepBtn'),
        errorBox: $('errorBox'),

        titleInput: $('titleInput'),
        exportBtn: $('exportBtn'),
        importBtn: $('importBtn'),
        importFile: $('importFile'),

        lastAmountText: $('lastAmountText'),
        lastDeltaText: $('lastDeltaText'),
        nextAmountText: $('nextAmountText'),
        nextDeltaText: $('nextDeltaText'),

        // countdown ("次まで") はUI重複のため非表示

        // steps table
        stepsTbody: $('stepsTbody'),

        // time modal
        timeModal: $('timeModal'),
        timeModalBackdrop: $('timeModalBackdrop'),
        timeModalClose: $('timeModalClose'),
        modalMm: $('modalMm'),
        modalSs: $('modalSs'),
        modalAmountEnable: $('modalAmountEnable'),
        modalAmountInput: $('modalAmountInput'),
        modalAmountUnit: $('modalAmountUnit'),
        modalTargetInfo: $('modalTargetInfo'),
        modalUnsetBtn: $('modalUnsetBtn'),
        modalCancelBtn: $('modalCancelBtn'),
                modalOkBtn: $('modalOkBtn'),

        // theme modal (v7)
        themeBtn: $('themeBtn'),
        themeModal: $('themeModal'),
        themeModalBackdrop: $('themeModalBackdrop'),
        themeModalClose: $('themeModalClose'),
        themeCancelBtn: $('themeCancelBtn'),
        themeOkBtn: $('themeOkBtn'),
        themeColorInput: $('themeColorInput'),

      };

      /** ------------------------------
       * App State
       * ------------------------------ */
      const state = {
        unit: 'ml',
        /** @type {Array<{id:string,timeMs:number|null,amount:number|null,notified:boolean,notifiedAtMs:number|null,completed:boolean}>} */
        steps: [],

        running: false,
        startAtPerf: 0,
        accumulatedMs: 0,
        tickTimer: null,

        // time modal
        modalStepId: null,

        // audio
        audioCtx: null,
      };

      /** ------------------------------
       * Audio / Feedback
       * ------------------------------ */
      function beep(){
        try{
          if (!state.audioCtx){
            state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          const ctx = state.audioCtx;
          if (ctx.state === 'suspended') ctx.resume();

          const osc = ctx.createOscillator();
          const gain = ctx.createGain();

          osc.type = 'sine';
          osc.frequency.value = 880;
          const now = ctx.currentTime;

          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);

          osc.connect(gain);
          gain.connect(ctx.destination);

          osc.start(now);
          osc.stop(now + 0.2);
        }catch(e){
          console.warn('beep failed:', e);
        }
      }

      function vibrate(){
        try{
          if (navigator.vibrate) navigator.vibrate([100, 50, 200]);
        }catch(e){
          console.warn('vibrate failed:', e);
        }
      }

      function flash(){
        dom.timeBox.classList.remove('flash');
        void dom.timeBox.offsetWidth;
        dom.timeBox.classList.add('flash');
      }

      /** ------------------------------
       * Core time helpers
       * ------------------------------ */
      function getElapsedMs(){
        if (!state.running) return state.accumulatedMs;
        return state.accumulatedMs + (performance.now() - state.startAtPerf);
      }

      function getOrderedTimedSteps(){
        // timeMs 昇順、null は除外。安定ソート。
        return state.steps
          .map((s, idx) => ({...s, _idx: idx}))
          .filter(s => s.timeMs != null)
          .sort((a,b) => (a.timeMs - b.timeMs) || (a._idx - b._idx))
          .map(({_idx, ...s}) => s);
      }

      function sortStepsInPlace(){
        state.steps = state.steps
          .map((s, idx) => ({...s, _idx: idx}))
          .sort((a,b) => {
            const at = a.timeMs, bt = b.timeMs;
            const aNull = (at == null), bNull = (bt == null);
            if (aNull && bNull) return a._idx - b._idx;
            if (aNull) return 1;
            if (bNull) return -1;
            if (at !== bt) return at - bt;
            return a._idx - b._idx;
          })
          .map(({_idx, ...s}) => s);
      }

      /** ------------------------------
       * Validation / Error UI
       * ------------------------------ */
      function clearError(){
        dom.errorBox.textContent = '';
        dom.errorBox.classList.remove('show');
      }

      function showError(msg){
        dom.errorBox.textContent = msg;
        dom.errorBox.classList.add('show');
      }

      function clearInvalidMarks(){
        dom.titleInput.classList.remove('inputInvalid');
        [...dom.stepsTbody.querySelectorAll('.tr')].forEach(tr => tr.classList.remove('invalid'));
      }

      function markInvalidRows(){
        [...dom.stepsTbody.querySelectorAll('.tr')].forEach(tr => tr.classList.remove('invalid'));
        for (const s of state.steps){
          if (s.timeMs == null || s.amount == null){
            const tr = dom.stepsTbody.querySelector(`.tr[data-id="${CSS.escape(s.id)}"]`);
            if (tr) tr.classList.add('invalid');
          }
        }
      }

      function validateStepsRequired(){
        // 0行は開始不可
        if (state.steps.length === 0){
          showError('ステップがありません（＋で行を追加してください）。');
          return false;
        }
        let ok = true;
        for (const s of state.steps){
          if (s.timeMs == null || s.amount == null) ok = false;
        }
        if (!ok){
          showError('未設定の行があります（時間と量をすべて設定してください）。');
        }
        return ok;
      }

      function validateTitleRequired(showMsg){
        const t = (dom.titleInput.value ?? '').trim();
        const ok = t.length > 0;
        dom.titleInput.classList.toggle('inputInvalid', !ok);
        if (!ok && showMsg){
          showError('タイトルが未入力です（タイトルは必須です）。');
        }
        return ok;
      }

      /** ------------------------------
       * CSV (Export / Import)
       * ------------------------------ */
      function buildCsvText(){
        const title = (dom.titleInput.value ?? '').trim();
        const safeTitle = escapeCsvTitle(title);
        const header = `"${safeTitle}",${state.unit}`;

        const sorted = state.steps
          .map((s, idx) => ({...s, _idx: idx}))
          .sort((a,b) => {
            const at=a.timeMs, bt=b.timeMs;
            if (at==null && bt==null) return a._idx - b._idx;
            if (at==null) return 1;
            if (bt==null) return -1;
            if (at!==bt) return at-bt;
            return a._idx - b._idx;
          });

        const lines = [header];
        for (const s of sorted){
          lines.push(`${msToMmSs(s.timeMs)},${s.amount}`);
        }
        return lines.join('\r\n');
      }

      function downloadCsv(filename, csvText){
        const bom = '\uFEFF';
        const blob = new Blob([bom + csvText], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      function parseCsvText(text){
        const raw = String(text ?? '');
        const lines = raw.replace(/^\uFEFF/, '').split(/\r\n|\n|\r/);
        const nonEmpty = lines.filter(l => l.trim() !== '');
        if (nonEmpty.length < 1) throw new Error('CSVが空です。');

        const meta = nonEmpty[0].trim();
        const m = meta.match(/^"((?:[^"]|"")*)",\s*(ml|l|mg|g)\s*$/);
        if (!m) throw new Error('1行目（メタ情報）の形式が不正です。形式："<title>",<unit>');
        const title = m[1].replace(/""/g, '"');
        const unitVal = m[2];

        const stepLines = nonEmpty.slice(1);
        if (stepLines.length === 0) throw new Error('ステップ行がありません。');

        const parsed = [];
        for (let i=0;i<stepLines.length;i++){
          const line = stepLines[i].trim();
          const mm = line.match(/^(\d{2}):(\d{2}),(\d+)$/);
          if (!mm) throw new Error(`${i+2}行目の形式が不正です（mm:ss,amount）。`);
          const m2 = Number(mm[1]);
          const s2 = Number(mm[2]);
          const amount = Number(mm[3]);
          if (!Number.isInteger(m2) || !Number.isInteger(s2) || m2 < 0 || m2 > 59 || s2 < 0 || s2 > 59){
            throw new Error(`${i+2}行目の時刻が範囲外です（00:00〜59:59）。`);
          }
          if (!Number.isInteger(amount) || amount < 0){
            throw new Error(`${i+2}行目の量が不正です（0以上の整数）。`);
          }
          parsed.push({
            id: newId(),
            timeMs: mmssToMs(m2, s2),
            amount,
            notified: false,
            notifiedAtMs: null,
            completed: false,
          });
        }

        // time昇順（同一時刻は入力順保持）
        const stable = parsed.map((s, idx) => ({...s, _idx: idx}))
          .sort((a,b) => (a.timeMs - b.timeMs) || (a._idx - b._idx))
          .map(({_idx, ...s}) => s);

        return { title, unit: unitVal, steps: stable };
      }

      function applyImportedPreset(preset){
        stop(); // ensure stopped
        state.accumulatedMs = 0;

        state.unit = preset.unit;
        dom.unitSelect.value = state.unit;
        dom.unitLabel.textContent = `量(${state.unit})`;

        dom.titleInput.value = preset.title;

        state.steps = preset.steps;
        sortStepsInPlace();

        // reset step runtime flags
        for (const s of state.steps){
          s.notified = false;
          s.notifiedAtMs = null;
          s.completed = false;
        }

        clearError();
        clearInvalidMarks();
        renderAll();
      }

      /** ------------------------------
       * Time modal
       * ------------------------------ */
      function isTimeModalOpen(){
        return !dom.timeModal.classList.contains('hidden');
      }

      function openTimeModal(stepId){
        if (state.running) return;
        const s = state.steps.find(x => x.id === stepId);
        if (!s) return;

        state.modalStepId = stepId;

        const mmVal = (s.timeMs == null) ? 0 : Math.floor(s.timeMs / 60000);
        const ssVal = (s.timeMs == null) ? 0 : Math.floor((s.timeMs % 60000) / 1000);
        dom.modalMm.value = String(mmVal);
        dom.modalSs.value = String(ssVal);

        // amount (optional in modal)
        dom.modalAmountUnit.textContent = state.unit;
        dom.modalAmountInput.classList.remove('inputInvalid');
        if (s.amount != null){
          dom.modalAmountEnable.checked = true;
          dom.modalAmountInput.disabled = false;
          dom.modalAmountInput.value = String(s.amount);
        }else{
          dom.modalAmountEnable.checked = false;
          dom.modalAmountInput.disabled = true;
          dom.modalAmountInput.value = '';
        }

        const labelTime = (s.timeMs == null) ? '未設定' : msToMmSs(s.timeMs);
        const labelAmount = (s.amount == null) ? '量未設定' : `${s.amount}${state.unit}`;
        dom.modalTargetInfo.textContent = `対象：${labelTime} ／ ${labelAmount}`;

        dom.timeModal.classList.remove('hidden');
        dom.timeModal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
        dom.modalOkBtn.focus({ preventScroll:true });
      }

      function closeTimeModal(){
        state.modalStepId = null;
        dom.timeModal.classList.add('hidden');
        dom.timeModal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
      }

      /** ------------------------------
       * Theme modal (v7)
       * ------------------------------ */
      function cssVar(name){
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }

      function hexToRgb(hex){
        const h = String(hex || '').trim().replace(/^#/, '');
        if (!/^[0-9a-fA-F]{6}$/.test(h)) return null;
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return { r, g, b };
      }

      function applyThemeColor(hex){
        const rgb = hexToRgb(hex);
        if (!rgb) return;
        document.documentElement.style.setProperty('--accent', `#${String(hex).replace(/^#/, '').toLowerCase()}`);
        document.documentElement.style.setProperty('--accent-rgb', `${rgb.r},${rgb.g},${rgb.b}`);
      }

      function isThemeModalOpen(){
        return !dom.themeModal.classList.contains('hidden');
      }

      function openThemeModal(){
        if (state.running) return;
        const current = cssVar('--accent') || '#4ea1ff';
        dom.themeColorInput.value = current.startsWith('#') ? current : '#4ea1ff';

        dom.themeModal.classList.remove('hidden');
        dom.themeModal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
        dom.themeOkBtn.focus({ preventScroll:true });
      }

      function closeThemeModal(){
        dom.themeModal.classList.add('hidden');
        dom.themeModal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
      }

      function commitThemeFromModal(){
        applyThemeColor(dom.themeColorInput.value);
        closeThemeModal();
      }


      function applyTimeModalValue(mode){
        if (state.modalStepId == null) return;
        const s = state.steps.find(x => x.id === state.modalStepId);
        if (!s) return;

        // time
        if (mode === 'unset'){
          s.timeMs = null;
        }else{
          const mm = Number(dom.modalMm.value);
          const ss = Number(dom.modalSs.value);
          s.timeMs = mmssToMs(mm, ss);
        }

        // amount (optional in modal)
        // - checkbox OFF: do not change amount
        // - checkbox ON : apply input (empty => null)
        if (mode !== 'unset' && dom.modalAmountEnable && dom.modalAmountEnable.checked){
          const raw = (dom.modalAmountInput.value ?? '').trim();
          dom.modalAmountInput.classList.remove('inputInvalid');

          if (raw === ''){
            s.amount = null;
          }else{
            const n = Number(raw);
            const ok = Number.isFinite(n) && Number.isInteger(n) && n >= 0;
            if (!ok){
              dom.modalAmountInput.classList.add('inputInvalid');
              showError('量は 0 以上の整数で入力してください（量は未入力でもOKです）。');
              return; // keep modal open
            }
            s.amount = n;
          }
        }

        sortStepsInPlace();
        renderSteps(); // only table needs rebuild
        closeTimeModal();
        renderTop();   // update side labels
      }

      /** ------------------------------
       * Notification / Completion / Next calculation
       * ------------------------------ */
      function processNotifications(elapsedMs){
        let fired = false;
        for (const s of state.steps){
          if (s.timeMs == null) continue;
          if (s.notified) continue;
          if (elapsedMs >= s.timeMs){
            s.notified = true;
            s.notifiedAtMs = Math.floor(elapsedMs);
            fired = true;
          }
        }
        if (fired){
          beep();
          vibrate();
          flash();
        }
      }

      function computeCompletion(elapsedMs){
        // 完了の判定は「時間昇順に並んだ“ステップの並び”」で判断する（同一時刻にも対応）
        const ordered = getOrderedTimedSteps();

        const indexById = new Map();
        ordered.forEach((s, i) => indexById.set(s.id, i));

        for (const s of state.steps){
          if (s.timeMs == null){
            s.completed = false;
            continue;
          }
          if (!s.notified){
            s.completed = false;
            continue;
          }

          const i = indexById.get(s.id);
          if (i == null){
            s.completed = false;
            continue;
          }

          const isLast = i === ordered.length - 1;
          if (!isLast){
            const nextTime = ordered[i + 1].timeMs;
            s.completed = elapsedMs >= nextTime;
          }else{
            s.completed = elapsedMs >= (s.timeMs + 6000);
          }
        }
      }

      function computeNextVisual(elapsedMs){
        const candidates = getOrderedTimedSteps().filter(s => !s.completed);
        if (candidates.length === 0) return { nextId: null, cls: null, deltaMs: null };

        let current = null;
        for (const s of candidates){
          if (s.timeMs <= elapsedMs) current = s;
          else break;
        }
        const next = current ?? candidates[0];
        const delta = elapsedMs - next.timeMs;

        if (delta >= 0 && delta < 3000) return { nextId: next.id, cls: 'next-orange', deltaMs: delta };
        if (delta >= 3000) return { nextId: next.id, cls: 'next-red', deltaMs: delta };
        return { nextId: next.id, cls: 'next-up', deltaMs: delta };
      }

      function computeSideAmounts(elapsedMs){
        const last = state.steps
          .filter(s => s.timeMs != null && s.amount != null && s.notified)
          .slice()
          .sort((a,b) => {
            const an = a.notifiedAtMs ?? -1;
            const bn = b.notifiedAtMs ?? -1;
            return (bn - an) || ((b.timeMs ?? 0) - (a.timeMs ?? 0));
          })[0] ?? null;

        const next = getOrderedTimedSteps()
          .filter(s => s.amount != null && s.timeMs > elapsedMs && !s.completed)
          [0] ?? null;

        const lastDeltaMs = (last && last.timeMs != null) ? (elapsedMs - last.timeMs) : null; // 設定時間からの経過
        const nextDeltaMs = (next && next.timeMs != null) ? (next.timeMs - elapsedMs) : null; // 次の設定時間まで

        return {
          lastText: last ? `${last.amount}${state.unit}` : null,
          nextText: next ? `${next.amount}${state.unit}` : null,

          lastDeltaText: (lastDeltaMs != null && lastDeltaMs >= 0) ? `+${msToMmSs(lastDeltaMs)}` : null,
          nextDeltaText: (nextDeltaMs != null && nextDeltaMs >= 0) ? `-${msToMmSs(nextDeltaMs)}` : null,
        };
      }

      function computeCountdown(elapsedMs){
        // “次に到達するべき時刻”＝未通知の最小 timeMs（同一時刻は先頭）
        const target = getOrderedTimedSteps().find(s => !s.notified) ?? null;
        if (!target) return { show:false, text:'' };

        const diffMs = target.timeMs - elapsedMs;
        const absText = msToMmSs(Math.abs(diffMs));
        const prefix = diffMs >= 0 ? 'T-' : 'T+';
        return { show:true, text: `${prefix}${absText}` };
      }

      /** ------------------------------
       * ViewModel Builder
       * ------------------------------ */
      function buildViewModel(){
        const elapsedMs = getElapsedMs();
        const side = computeSideAmounts(elapsedMs);
        const nextVisual = computeNextVisual(elapsedMs);

        return {
          elapsedMs,
          elapsedText: msToMmSs(elapsedMs),
          running: state.running,
          unit: state.unit,

          side,
          nextVisual,
        };
      }

      /** ------------------------------
       * Render
       * ------------------------------ */
      function setRunningUI(){
        const running = state.running;

        dom.startStopBtn.textContent = running ? 'ストップ' : 'スタート';

        dom.unitSelect.disabled = running;
        dom.addStepBtn.disabled = running;
        dom.resetBtn.disabled = running || state.accumulatedMs === 0;

        dom.titleInput.disabled = running;
        dom.exportBtn.disabled = running;
        dom.importBtn.disabled = running;
        dom.importFile.disabled = running;

         dom.themeBtn.disabled = running;

        // table inputs/buttons
        [...dom.stepsTbody.querySelectorAll('input,button')].forEach(el => {
          if (el.matches('button[data-time],button[data-del],input[type="number"]')) el.disabled = running;
        });
      }

      function renderTop(vm){
        const view = vm ?? buildViewModel();
        dom.elapsed.textContent = view.elapsedText;        // side amounts: label is always visible, value is "visibility:hidden" when empty (幅は固定)
        if (view.side.lastText){
          dom.lastAmountText.textContent = view.side.lastText;
          dom.lastAmountText.classList.remove('is-empty');
        }else{
          dom.lastAmountText.textContent = '----';
          dom.lastAmountText.classList.add('is-empty');
        }

        if (view.side.lastDeltaText){
          dom.lastDeltaText.textContent = view.side.lastDeltaText;
          dom.lastDeltaText.classList.remove('is-empty');
        }else{
          dom.lastDeltaText.textContent = '----';
          dom.lastDeltaText.classList.add('is-empty');
        }

        if (view.side.nextText){
          dom.nextAmountText.textContent = view.side.nextText;
          dom.nextAmountText.classList.remove('is-empty');
        }else{
          dom.nextAmountText.textContent = '----';
          dom.nextAmountText.classList.add('is-empty');
        }

        if (view.side.nextDeltaText){
          dom.nextDeltaText.textContent = view.side.nextDeltaText;
          dom.nextDeltaText.classList.remove('is-empty');
        }else{
          dom.nextDeltaText.textContent = '----';
          dom.nextDeltaText.classList.add('is-empty');
        }


        dom.resetBtn.disabled = state.running || view.elapsedMs === 0;
      }

      function renderSteps(){
        dom.stepsTbody.innerHTML = '';

        for (const s of state.steps){
          const tr = document.createElement('tr');
          tr.className = 'tr';
          tr.dataset.id = s.id;

          // time
          const tdTime = document.createElement('td');
          tdTime.className = 'cellTime';

          const timeLabel = document.createElement('div');
          timeLabel.className = 'rowMeta';
          timeLabel.textContent = '時間';

          const timeBtn = document.createElement('button');
          timeBtn.type = 'button';
          timeBtn.className = 'timeBtn ghost';
          timeBtn.dataset.time = '1';

          const timeText = (s.timeMs == null) ? '未設定' : msToMmSs(s.timeMs);
          timeBtn.innerHTML = `<span class="main">${timeText}</span><span class="sub">タップして時間/量を設定</span>`;
          timeBtn.addEventListener('click', () => {
            if (state.running) return;
            openTimeModal(s.id);
            clearError();
          });

          const timeHint = document.createElement('div');
          timeHint.className = 'rowMeta';
          timeHint.textContent = `表示: ${(s.timeMs == null) ? '未設定' : msToMmSs(s.timeMs)}`;

          tdTime.appendChild(timeLabel);
          tdTime.appendChild(timeBtn);
          tdTime.appendChild(timeHint);

          // amount
          const tdAmount = document.createElement('td');
          tdAmount.className = 'cellAmount';

          const amountLabel = document.createElement('div');
          amountLabel.className = 'rowMeta';
          amountLabel.textContent = '量';

          const amountWrap = document.createElement('div');
          amountWrap.className = 'amountWrap';

          const amountInput = document.createElement('input');
          amountInput.type = 'number';
          amountInput.inputMode = 'numeric';
          amountInput.min = '0';
          amountInput.step = '1';
          amountInput.placeholder = '整数 (0以上)';
          if (s.amount != null) amountInput.value = String(s.amount);

          amountInput.addEventListener('input', () => {
            const v = amountInput.value.trim();
            if (v === ''){
              s.amount = null;
              return;
            }
            const n = Number(v);
            if (!Number.isFinite(n) || !Number.isInteger(n) || n < 0){
              s.amount = null;
              return;
            }
            s.amount = n;
          });

          const unitBadge = document.createElement('div');
          unitBadge.className = 'unitBadge';
          unitBadge.textContent = state.unit;

          amountWrap.appendChild(amountInput);
          amountWrap.appendChild(unitBadge);

          const amountHint = document.createElement('div');
          amountHint.className = 'rowMeta';
          amountHint.textContent = (s.amount == null) ? '未設定' : `設定: ${s.amount}${state.unit}`;

          tdAmount.appendChild(amountLabel);
          tdAmount.appendChild(amountWrap);
          tdAmount.appendChild(amountHint);

          // action
          const tdAction = document.createElement('td');
          tdAction.className = 'cellAction';

          const actionLabel = document.createElement('div');
          actionLabel.className = 'rowMeta';
          actionLabel.textContent = '操作';

          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.textContent = 'クリア（行削除）';
          delBtn.dataset.del = '1';
          delBtn.addEventListener('click', () => {
            if (state.running) return;
            state.steps = state.steps.filter(x => x.id !== s.id);
            renderAll();
            clearError();
          });

          const status = document.createElement('div');
          status.className = 'rowMeta';
          status.textContent =
            (s.timeMs == null) ? '' :
            (s.completed ? '完了' : (s.notified ? '通知済み（未完了）' : '未通知'));

          tdAction.appendChild(actionLabel);
          tdAction.appendChild(delBtn);
          tdAction.appendChild(status);

          tr.appendChild(tdTime);
          tr.appendChild(tdAmount);
          tr.appendChild(tdAction);

          dom.stepsTbody.appendChild(tr);
        }

        setRunningUI();
        applyRowStates();
      }

      function applyRowStates(vm){
        const view = vm ?? buildViewModel();
        const { nextId, cls } = view.nextVisual;

        [...dom.stepsTbody.querySelectorAll('.tr')].forEach(tr => {
          const id = tr.dataset.id;
          const s = state.steps.find(x => x.id === id);
          if (!s) return;

          tr.classList.remove('next-up','next-orange','next-red','completed');

          if (s.completed){
            tr.classList.add('completed');
          }else if (id === nextId && cls){
            tr.classList.add(cls);
          }
        });
      }

      function renderAll(){
        const vm = buildViewModel();
        renderTop(vm);
        renderSteps();
        applyRowStates(vm);
      }

      /** ------------------------------
       * Actions: Step CRUD / StartStop / Reset
       * ------------------------------ */
      function addStep(){
        state.steps.push({
          id: newId(),
          timeMs: null,
          amount: null,
          notified: false,
          notifiedAtMs: null,
          completed: false,
        });
        sortStepsInPlace();
        renderAll();
      }

      function start(){
        clearError();
        clearInvalidMarks();

        const ok = validateStepsRequired();
        if (!ok){
          markInvalidRows();
          return;
        }

        state.running = true;
        state.startAtPerf = performance.now();
        setRunningUI();

        if (state.tickTimer) clearInterval(state.tickTimer);
        state.tickTimer = setInterval(tick, TICK_MS);
        tick();
      }

      function stop(){
        if (!state.running) return;
        const elapsedMs = getElapsedMs();
        state.accumulatedMs = elapsedMs;

        state.running = false;
        setRunningUI();

        if (state.tickTimer){
          clearInterval(state.tickTimer);
          state.tickTimer = null;
        }
        tick();
      }

      function reset(){
        if (state.running) return;
        if (state.accumulatedMs === 0) return;

        state.accumulatedMs = 0;

        for (const s of state.steps){
          s.notified = false;
          s.notifiedAtMs = null;
          s.completed = false;
        }

        [...dom.stepsTbody.querySelectorAll('.tr')].forEach(tr => {
          tr.classList.remove('invalid','next-up','next-orange','next-red','completed');
        });

        clearError();
        renderAll();
      }

      /** ------------------------------
       * Tick loop
       * ------------------------------ */
      function tick(){
        const elapsedMs = getElapsedMs();

        // state updates
        processNotifications(elapsedMs);
        computeCompletion(elapsedMs);

        // render
        const vm = buildViewModel();
        renderTop(vm);
        applyRowStates(vm);
        dom.resetBtn.disabled = state.running || elapsedMs === 0;
      }

      /** ------------------------------
       * Bindings
       * ------------------------------ */
      function bindEvents(){
        dom.unitSelect.addEventListener('change', () => {
          if (state.running) return;
          state.unit = dom.unitSelect.value;
          dom.unitLabel.textContent = `量(${state.unit})`;
          renderAll();
        });

        dom.addStepBtn.addEventListener('click', () => {
          if (state.running) return;
          addStep();
          clearError();
        });

        dom.startStopBtn.addEventListener('click', () => {
          if (!state.running) start();
          else stop();
        });

        dom.resetBtn.addEventListener('click', () => reset());


        // Theme (gear)
        dom.themeBtn.addEventListener('click', () => {
          if (state.running) return;
          openThemeModal();
          clearError();
        });

        dom.themeModalBackdrop.addEventListener('click', () => closeThemeModal());
        dom.themeModalClose.addEventListener('click', () => closeThemeModal());
        dom.themeCancelBtn.addEventListener('click', () => closeThemeModal());
        dom.themeOkBtn.addEventListener('click', () => commitThemeFromModal());

        dom.themeColorInput.addEventListener('input', () => {
          // 反映はOK押下時のみ（ここでは何もしない）
        });

        // preset swatches -> set color input only
        [...dom.themeModal.querySelectorAll('.swatch')].forEach(btn => {
          btn.addEventListener('click', () => {
            const c = btn.getAttribute('data-color');
            if (c) dom.themeColorInput.value = c;
          });
        });

        // ESC でモーダルを閉じる
        document.addEventListener('keydown', (ev) => {
          if (ev.key !== 'Escape') return;
          if (isThemeModalOpen()) closeThemeModal();
          else if (isTimeModalOpen()) closeTimeModal();
        });


        dom.titleInput.addEventListener('input', () => {
          if (state.running) return;
          dom.titleInput.classList.remove('inputInvalid');
        });

        // Export
        dom.exportBtn.addEventListener('click', () => {
          if (state.running) return;
          clearError();
          clearInvalidMarks();

          const t = (dom.titleInput.value ?? '').trim();
          if (t.length === 0){
            dom.titleInput.classList.add('inputInvalid');
            showError('タイトルが未入力です（タイトルは必須です）。');
            return;
          }
          if (/\r|\n/.test(t)){
            dom.titleInput.classList.add('inputInvalid');
            showError('タイトルに改行を含めることはできません。');
            return;
          }

          const stepsOk = validateStepsRequired();
          if (!stepsOk){
            markInvalidRows();
            return;
          }

          const csv = buildCsvText();
          const safeName = t.replace(/[\/:*?"<>|]/g, '_').slice(0, 60) || 'preset';
          downloadCsv(`${safeName}.csv`, csv);
        });

        // Import
        dom.importBtn.addEventListener('click', () => {
          if (state.running) return;
          clearError();
          clearInvalidMarks();
          dom.importFile.click();
        });

        dom.importFile.addEventListener('change', async () => {
          if (state.running) return;
          clearError();
          clearInvalidMarks();

          const file = dom.importFile.files && dom.importFile.files[0] ? dom.importFile.files[0] : null;
          if (!file){
            dom.importFile.value = '';
            return;
          }

          try{
            const txt = await file.text();
            const preset = parseCsvText(txt);
            applyImportedPreset(preset);
          }catch(e){
            console.warn(e);
            showError(`読み込みに失敗しました：${e && e.message ? e.message : '不明なエラー'}`);
          }finally{
            dom.importFile.value = '';
          }
        });

        // Time modal init & bindings
        dom.modalMm.appendChild(buildOptions(0, 59));
        dom.modalSs.appendChild(buildOptions(0, 59));

        // amount optional toggle in modal
        dom.modalAmountEnable.addEventListener('change', () => {
          const on = dom.modalAmountEnable.checked;
          dom.modalAmountInput.disabled = !on;
          dom.modalAmountInput.classList.remove('inputInvalid');
          if (!on){
            // keep value for convenience, but it won't be applied
          }else{
            dom.modalAmountInput.focus({ preventScroll:true });
          }
        });

        dom.timeModalBackdrop.addEventListener('click', () => closeTimeModal());
        dom.timeModalClose.addEventListener('click', () => closeTimeModal());
        dom.modalCancelBtn.addEventListener('click', () => closeTimeModal());
        dom.modalOkBtn.addEventListener('click', () => applyTimeModalValue('ok'));
        dom.modalUnsetBtn.addEventListener('click', () => applyTimeModalValue('unset'));

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && isTimeModalOpen()){
            closeTimeModal();
          }
        });
      }

      /** ------------------------------
       * Init
       * ------------------------------ */
      function init(){
        // initial: 0 steps (user adds)
        state.steps = [];
        sortStepsInPlace();

        dom.unitLabel.textContent = `量(${state.unit})`;

        bindEvents();
        renderAll();
      }

      init();
    })();
  </script>
</body>
</html>
